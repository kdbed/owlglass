Introduction

* * *
# Basic Concepts


## 1. `Buffer Overflow`[^1]
[^1]: Primary reference for this section: _Penetration Testing with Shellcode_ - Hamza Megahed 

Buffer overflow is one of the oldest and most destructive vulnerabilities that could cause damage to an operating system (from both local and remote access).  Basically, certain functions don'tknow whether input data can fit inside the preallocated space or not; adding more data than the preallocated space results in overflow.  This can lead to a change in the execution flow of the program.  Shellcode is what we want to be executed after we gain control of the flow of execution.
## 2. `The Stack`
A stack is an allocated space in the memory for each running process, used to hold all of the variables inside it.  The OS is responsible for creating a memory layout for each running application, and within each memory layout, there is a stack.  A stack is also used to save the return address so that the code can go back to the calling function.  A stack uses _Last Input First Output_ (LIFO) to store elements in it, and there is a stack _pointer_, which points to the top of the stack, using _push_ to store an element at the top of the stack and _pop_ to extract the element from the top of the stack. 

Example code [^2]:
[^2]: _ibid_, p.27
```
    
    #include <stdio.h> 
    
    void function1()
    {
        int y=1;
        printf("This is function1\n");
    }
    void function2()
    {
        int z=2;
        printf("This is function2\n");
    }
    
    int main (int argc, char **argv[])
    {
        int x = 10;
        printf("This is the main function\n");
        function1();
        printf("After calling function1\n");
        function2();
        printf("After calling function2\n");
        return 0;
    }
```
The preceding code works in the following way:

1. The _main_ function will start first.  The variable _x_ will be pushed into the stack, and it will print out the sentence _This is the main function_.
2. The _main_ function will call _function1_, and before moving forward to _function1_, the address of _printf("After calling function1\n")_ will be saved into the stack in order to continue the execution flow.  After finishing _function1_ by pushing the variable _y_ in the stack, it will execute _printf("This is function1\n")_.
3. Then, go back to the _main_ function again to execute _printf("After calling function1\n")_ , and push the address of _printf("After calling function2\n")_.
4. Now control will move forward to execute _function2_ by pushing the variable _z_ into the stack then executing _printf("This is function2\n")_.  
5. Finally, return to _main_ and execute _printf("After calling function2\n")_.  
6. Exit.

## 3. `The Buffer` 

-
-
-







id: bbb0a34dcf4344faa5240a88925d20ec
parent_id: bedd3b05bdd04a02a2124dc29d0263e3
created_time: 2020-04-08T14:54:49.695Z
updated_time: 2020-04-08T17:09:21.517Z
is_conflict: 0
latitude: 0.00000000
longitude: 0.00000000
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2020-04-08T14:54:49.695Z
user_updated_time: 2020-04-08T17:09:21.517Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
type_: 1