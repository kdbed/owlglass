id: b47a935a03344b1db3d2e9ac6e5fd9f8
parent_id: 
item_type: 1
item_id: d83a066b026042299ad58e556c083416
item_updated_time: 1586540671228
title_diff: "@@ -0,0 +1,13 @@\n+Code Patterns\n"
body_diff: "@@ -0,0 +1,1025 @@\n+# Code Patterns%0A* * *%0A## %60Overview%60 %5B%5E1%5D%0A%5B%5E1%5D: 02/04/2020 10:56 ; _Reverse Engineering for Beginners_ - Dennis Yurichev%0A%0A### 1. Basic Ideas%0A%0AExperiment by writing small pieces of code -- e.g., in C or C++ -- then compile and examine assembly language output, which builds understanding of the relationship between the two.  A range of compilers is available at %5Bgodbolt%5D(https://godbolt.org).%0A%0AAnother exercise: write small C programs and gradually rewrite in assembly, attempting to make the code as small as possible (even though modern compilers can produce highly optimized output).  %0A%0A### 2. Optimization%0A%0A%0ACompilers typically have several levels of optimization (usually 3), with zero implying optimization is completely disabled.  Optimizations can be targeted towards code size or code speed.  Compilers can also produce debug information, which may include links between each line of source code and its respective machine code address.  If the compiler optimizes the code, there may be no such one-to-one mapping.  \n"
metadata_diff: {"new":{"id":"d83a066b026042299ad58e556c083416","parent_id":"f0d4645209ed43adba531d1a704491a2","latitude":"0.00000000","longitude":"0.00000000","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2020-04-10T17:49:48.050Z
created_time: 2020-04-10T17:49:48.050Z
type_: 13